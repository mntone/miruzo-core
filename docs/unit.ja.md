# manbytes — 文化的背景を持つ、実用的なサイズ単位

## 1. 背景: 日本の 10<sup>4</sup> 桁区切り

日本語（および中国語圏）では、数値を **4 桁（10<sup>4</sup>）単位で
区切る**数体系が一般的に使われています。代表的な桁名称として、次のもの
が日常語彙として定着しています。

- man（万, 10<sup>4</sup>）
- oku（億, 10<sup>8</sup>）
- chō（兆, 10<sup>12</sup>）
- kei（京, 10<sup>16</sup>）

この体系では、「1 万」「12 万」「300 万」といった表現が直感的に理解され、
桁の増減が *量感* として把握しやすいという特徴があります。

一方、欧米圏で主流の数体系は **3 桁区切り（10<sup>3</sup>）** を基本とし、

- thousand (10<sup>3</sup>)
- million (10<sup>6</sup>)
- billion (10<sup>9</sup>)

といった単位で構成されています。この違いは、しばしば単なる文化的背景の
差として捉えられがちです。しかし実際には、数値をユーザーインターフェー
ス上で提示する際に、無視できない実装上の影響を持ちます。

特に画像処理や表示戦略の文脈では、10<sup>4</sup> byte（約 10KB）を基準
とした区切りは、

- 小さすぎず
- かつ粗すぎない

という点で、扱いやすいスケールになります。


## 2. なぜ kilobytes や megabytes ではないのか

既存のバイト単位（kilobytes や megabytes）は、**実装上は標準的である一
方、UX 上の判断材料としては扱いにくい**側面があります。

**kilobytes (10<sup>3</sup> bytes)**

単位が<u>細かすぎます</u>。数値の変動が大きくなりやすく、画像サイズや
ロード時間を<u>ざっくり分類</u>する用途ではノイズになります。

たとえば 120 KB と 180 KB の差は数値上は明確ですが、表示戦略やユーザー
体感においては、同じクラスとして扱いたいケースがほとんどです。

**megabytes (10<sup>6</sup> bytes)**

一方で、megabytes は粗すぎます。1.1MB と 1.9MB のような差は、モバイル
環境では明確な体感差を生みますが、単位表記上は同じ「約 2MB」として埋もれ
てしまいます。

**kibibyte / mebibyte 系 (2<sup>10</sup>, 2<sup>20</sup> bytes)**

kibibyte（KiB）や mebibyte（MiB）などの 1024 系単位は、技術的には正確
です。しかし、UX 戦略（プログレス表示、事前ロード判定、分岐条件）に使う
には精度が過剰です。

これらの用途では、**厳密さよりも安定した分類が重要**になります。


## 3. なぜ 10<sup>4</sup> が画像サイズに適しているのか

画像ロードや表示戦略を決める際には、正確なバイト数よりも<u>おおよその重量感
</u>が重要になります。

多くの UI では、画像サイズに応じて次のような判断を行います。

- 即時表示できるか
- ロードが速いと感じられるか
- プログレス UI を出すべきか
- 特別な扱いが必要か

実際の運用では、次のようなレンジ分けが自然に発生します。

- 0〜100 KB: 即時表示
- 200〜400 KB: ロードが速い
- 1〜2 MB: モバイル環境で 0.3〜1.0 秒程度
- 4〜8 MB: プログレス UI を出したい
- 10 MB 以上: 特別扱いが必要

このとき、10<sup>4</sup> bytes（約 10 KB）単位で区切ると、これらのレンジ
を<u>無理なく連続的に表現</u>できます。

例えば、次のように表せます。

- 28 manbytes → 約 280 KB
- 120 manbytes → 約 1.2 MB
- 480 manbytes → 約 4.8 MB

この表現では、数値そのものが**UX 上の判断材料として直接使えるスケール**
になります。


## 4. manbytes という単位

manbytes は、10<sup>4</sup> bytes を基準としたサイズ単位です。

**1 manbyte = 10⁴ bytes**

miruzo では、ファイルサイズをこの単位に正規化して扱います。生のバイト数は
次の式で manbytes に変換されます。

**manbytes = ceil(bytes / 10_000)**

この変換により、小さなファイルであっても 0 にならず、意味のあるサイズクラス
として扱われます。その結果、UX 上の判断が安定します。

manbytes は**正確な容量表示を目的とした単位ではありません**。主な用途は
次のとおりです。

- 画像ロード戦略の分岐
- プログレス表示の有無判定
- 事前ロードや遅延ロードの判断
- 表示優先度のヒューリスティック

実際のバイト数が必要な場面では、従来どおり bytes や kilobytes /
megabytes を併用します。

### 実装上の補足

manbytes を利用するコード実装では、本セクションで定義された単位および
変換式を前提とします。

関連する実装は以下を参照してください。

- [`miruzo-core/app/models/api/images/variant.py`](../app/models/api/images/variant.py)
- [`miruzo-core/app/models/api/utils/units.py`](../app/models/api/utils/units.py)

切り上げを用いることで、`manbytes = 0` は「ファイルサイズが 0 の場合」のみ
に対応し、小さな非ゼロサイズが 0 として表現されることを防ぎます。


## 5. 将来的な拡張について: okubytes と chobytes

10<sup>4</sup>（万）のさらに上には、10<sup>8</sup>（億）、10<sup>12</sup>
（兆）、10<sup>16</sup>（京）といった桁体系が存在します。

理論上は、これらを拡張単位として次のように対応づけることも可能です。

```
man (万, 10⁴ bytes) → manbytes
oku (億, 10⁸ bytes) → okubytes
chō (兆, 10¹² bytes) → chobytes
kei (京, 10¹⁶ bytes) → keibytes
```

ただし、**miruzo では現在 manbytes 以外の単位を使用しません**。

画像表示やロード戦略という用途においては、10<sup>4</sup> bytes を基準と
した粒度で十分であり、それ以上の桁を導入する実用的な必要性は現時点では
ありません。

これらの名称は、数体系としての一貫性や将来的な拡張可能性を示すための補足
情報として位置づけられます。

## 6. Non-goals（本ドキュメントで扱わないこと）

manbytes は、正確な容量管理やストレージ計測を目的とした単位ではありませ
ん。また、ネットワーク帯域の厳密な推定、課金計算、あるいは機械学習モデル
の入力表現として使用することも想定していません。


## 7. 文化的だが、実用的でもある

manbytes は、日本の数の文化（10<sup>4</sup> 区切り）に着想を得た単位です。
しかし、その導入理由は、文化的な面白さそのものではありません。

画像表示やロード戦略といった UI / UX の実装において、<u>扱いやすい粒度で
サイズを捉えられる</u>という実用上の利点があります。

manbytes は、

- 正確な容量を表すための単位ではなく
- 人間の判断に近い形でサイズを分類するための単位

として設計されています。

miruzo では、この特性を活かし、画像の表示戦略やロード制御におけるヒュー
リスティックとして manbytes を利用します。

文化と工学が交差するところに生まれた、軽量で実装に馴染むサイズスケールで
す。


## 8. まとめ

- manbytes は 10<sup>4</sup> bytes を基準としたサイズ単位
- 日本語の数体系に由来するが、目的は実装上の実用性
- 画像サイズを<u>安定した粒度で分類</u>するのに適している
- UX 判断やロード戦略のヒューリスティックとして使用する
- miruzo では manbytes のみを採用する
